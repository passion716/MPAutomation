# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MPautomation0329.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from distutils.cygwinccompiler import Mingw32CCompiler
from pyexpat import model
import sys
import os
import re
import traceback
from types import NoneType
import pandas as pd
import numpy as np
import cv2
import io
import glob
import asyncio
import nest_asyncio
import mplcursors


from PyQt5 import QtCore, QtGui, QtWidgets, Qt
from PyQt5.QtWidgets import QApplication, QMainWindow
from math import isclose
from scipy.interpolate import interp1d
from pandas import ExcelWriter
from matplotlib.figure import Figure
from matplotlib.ticker import MultipleLocator
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
from tensorflow import keras

from pickle import load

nest_asyncio.apply()

import threading

#test
import globalValue
import Wrap_asyncIo
import ThreadFileRead

import loggingMd as lggMd

nest_asyncio.apply()

globalValue.initloop()
globalValue.initResult()
lggMd.initlogginObj()
# def read_spa(filepath): # https://github.com/lerkoah/spa-on-python/blob/master/LoadSpectrum.py
#     '''
#     Input
#     Read a file (string) *.spa
#     ----------
#     Output
#     Return spectra, wavelenght (nm), titles
#     '''
#     with open(filepath, 'rb') as f:
#         f.seek(564)
#         Spectrum_Pts = np.fromfile(f, np.int32, 1)[0]
#         f.seek(30)
#         SpectraTitles = np.fromfile(f, np.uint8, 255)
#         SpectraTitles = ''.join([chr(x) for x in SpectraTitles if x != 0])

#         f.seek(576)
#         Max_Wavenum = np.fromfile(f, np.single, 1)[0]
#         Min_Wavenum = np.fromfile(f, np.single, 1)[0]
#         # print(Min_Wavenum, Max_Wavenum, Spectrum_Pts)
#         Wavenumbers = np.flip(np.linspace(Min_Wavenum, Max_Wavenum, Spectrum_Pts))

#         f.seek(288);

#         Flag = 0
#         while Flag != 3:
#             Flag = np.fromfile(f, np.uint16, 1)

#         DataPosition = np.fromfile(f, np.uint16, 1)
#         f.seek(DataPosition[0])

#         Spectra = np.fromfile(f, np.single, Spectrum_Pts)
#     return Spectra, Wavenumbers, SpectraTitles

# async def get_info_from_spa(filepath):
#     spec, wn, tit =  await loop.run_in_executor(None, read_spa, filepath)
    
#     return spec, wn, tit
# loop = asyncio.get_event_loop()

# async def get_spec(input_list):
    
#     info = [asyncio.ensure_future(get_info_from_spa(i)) for i in input_list]
#     r = await asyncio.gather(*info)
#     global results
#     results = r 
#     return results

def get_img_from_fig(fig, dpi=300):
    lggMd.LogObj.info('Enter get_img_from_fig')
    buf = io.BytesIO()
    fig.savefig(buf, format="png", dpi=dpi, bbox_inches='tight', pad_inches=0)
    buf.seek(0)
    img_arr = np.frombuffer(buf.getvalue(), dtype=np.uint8)
    buf.close()
    img = cv2.imdecode(img_arr, 1)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    return img

def find_nearest(array, value):  # 가장 가까운 예상값 구하기. 
    lggMd.LogObj.info('Enter find_nearest')
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return array[idx]

def find_second_near(array, value):
    lggMd.LogObj.info('Enter find_second_near')
    array = np.asarray(array)
    L = list(np.abs(array - value))
    sorted_list = sorted(L)

    for i in range(len(sorted_list)):
        if sorted_list[i] != sorted_list[0]:
            second_smallest = sorted_list[i] #loop 정지시키기
            break

    min2 = L.index(second_smallest)

    return array[min2]

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        lggMd.LogObj.info('Enter setupUi')
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1300, 1000)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setObjectName("tabWidget")
        self.MLResult = QtWidgets.QWidget()
        self.MLResult.setObjectName("Result(ML)")
        self.MLgridLayout = QtWidgets.QGridLayout(self.MLResult)
        self.MLgridLayout.setObjectName("gridLayoutml")
        self.MLlabel_image = QtWidgets.QLabel(self.MLResult)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.MLlabel_image.setFont(font)
        self.MLlabel_image.setObjectName("label_imageml")
        self.MLgridLayout.addWidget(self.MLlabel_image, 2, 0, 1, 1)
        self.MLMapping = QtWidgets.QWidget(self.MLResult)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.MLMapping.sizePolicy().hasHeightForWidth())
        self.MLMapping.setSizePolicy(sizePolicy)
        self.MLMapping.setObjectName("Mappingml")
        self.MLgridLayout.addWidget(self.MLMapping, 3, 0, 1, 1)

        self.figure_map_ml = Figure()
        self.canvas_map_ml = FigureCanvas(self.figure_map_ml)
        self.toolbar_map_ml = NavigationToolbar(self.canvas_map_ml, self.MLResult, coordinates=False)
        self.mappingbox_ml = QtWidgets.QVBoxLayout(self.MLMapping)
        self.mappingbox_ml.addWidget(self.toolbar_map_ml)
        self.mappingbox_ml.addWidget(self.canvas_map_ml)

        self.MLlabel_info = QtWidgets.QLabel(self.MLResult)
        self.MLlabel_info.setObjectName("label_infoml")
        self.MLlabel_info.setAlignment(QtCore.Qt.AlignCenter)
        self.MLgridLayout.addWidget(self.MLlabel_info, 2, 2, 1, 1) 

        self.MLresult_info = QtWidgets.QTableWidget(self.MLResult)
        self.MLresult_info.setRowCount(20)
        self.MLresult_info.setColumnCount(7)
        self.MLresult_info.setHorizontalHeaderLabels(['X', 'Y', 'width', 'length', 'area', 'matching score', 'class'])
        self.MLresult_info.setObjectName("result_infoml")
        self.MLgridLayout.addWidget(self.MLresult_info, 3, 2, 1, 1)

        self.MLlabel_spectrum = QtWidgets.QLabel(self.MLResult)
        font = QtGui.QFont()
        font.setPointSize(24)
        self.MLlabel_spectrum.setFont(font)
        self.MLlabel_spectrum.setObjectName("label_spectrumml")
        self.MLgridLayout.addWidget(self.MLlabel_spectrum, 4, 0, 1, 1)

        self.MLSpectrum = QtWidgets.QWidget(self.MLResult)
        self.MLSpectrum.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.MLSpectrum.sizePolicy().hasHeightForWidth())
        self.MLSpectrum.setSizePolicy(sizePolicy)
        self.MLSpectrum.setMinimumSize(QtCore.QSize(0, 0))
        self.MLSpectrum.setSizeIncrement(QtCore.QSize(0, 0))
        self.MLSpectrum.setBaseSize(QtCore.QSize(0, 0))
        self.MLSpectrum.setObjectName("Spectrumml")
        self.MLgridLayout.addWidget(self.MLSpectrum, 5, 0, 1, 3)

        self.figure_spectrum_ml = Figure()
        self.canvas_spectrum_ml = FigureCanvas(self.figure_spectrum_ml)
        self.toolbar_spectrum_ml = NavigationToolbar(self.canvas_spectrum_ml, self.MLResult, coordinates=False)
        self.spectrumbox_ml = QtWidgets.QVBoxLayout(self.MLSpectrum)
        self.spectrumbox_ml.addWidget(self.toolbar_spectrum_ml)
        self.spectrumbox_ml.addWidget(self.canvas_spectrum_ml)

        self.Result = QtWidgets.QWidget()
        self.Result.setObjectName("Result")
        self.gridLayout = QtWidgets.QGridLayout(self.Result)
        self.gridLayout.setObjectName("gridLayout")
        self.Spectrum = QtWidgets.QWidget(self.Result)
        self.Spectrum.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.Spectrum.sizePolicy().hasHeightForWidth())
        self.Spectrum.setSizePolicy(sizePolicy)
        self.Spectrum.setMinimumSize(QtCore.QSize(0, 0))
        self.Spectrum.setSizeIncrement(QtCore.QSize(0, 0))
        self.Spectrum.setBaseSize(QtCore.QSize(0, 0))
        self.Spectrum.setObjectName("Spectrum")
        self.gridLayout.addWidget(self.Spectrum, 5, 0, 1, 3)

        self.figure_spectrum = Figure()
        self.canvas_spectrum = FigureCanvas(self.figure_spectrum)
        self.toolbar_spectrum = NavigationToolbar(self.canvas_spectrum, self.Result, coordinates=False)
        self.spectrumbox = QtWidgets.QVBoxLayout(self.Spectrum)
        self.spectrumbox.addWidget(self.toolbar_spectrum)
        self.spectrumbox.addWidget(self.canvas_spectrum)

        self.result_info = QtWidgets.QTableWidget(self.Result)
        self.result_info.setRowCount(20)
        self.result_info.setColumnCount(6)
        self.result_info.setHorizontalHeaderLabels(['X', 'Y', 'width', 'length', 'area', 'matching factor'])
        self.result_info.setObjectName("result_info")
        self.gridLayout.addWidget(self.result_info, 3, 2, 1, 1)
        self.label_info = QtWidgets.QLabel(self.Result)
        self.label_info.setObjectName("label_info")
        self.label_info.setAlignment(QtCore.Qt.AlignCenter)
        self.gridLayout.addWidget(self.label_info, 2, 2, 1, 1)
        self.label_slider = QtWidgets.QLabel(self.Result)
        self.label_slider.setObjectName("label_slider")
        self.gridLayout.addWidget(self.label_slider, 2, 1, 1, 1)
        self.label_spectrum = QtWidgets.QLabel(self.Result)
        font = QtGui.QFont()
        font.setPointSize(24)
        self.label_spectrum.setFont(font)
        self.label_spectrum.setObjectName("label_spectrum")
        self.gridLayout.addWidget(self.label_spectrum, 4, 0, 1, 1)
        self.verticalSlider = QtWidgets.QSlider(self.Result)
        self.verticalSlider.setMouseTracking(True)
        self.verticalSlider.setTabletTracking(True)
        self.verticalSlider.setProperty("value", 70)
        self.verticalSlider.setOrientation(QtCore.Qt.Vertical)
        self.verticalSlider.setTickPosition(QtWidgets.QSlider.TicksBelow)
        self.verticalSlider.setTickInterval(0)
        self.verticalSlider.setRange(0, 100)
        self.verticalSlider.setPageStep(1)
        self.verticalSlider.setSingleStep(1)
        self.verticalSlider.valueChanged[int].connect(self.change_value)
        self.verticalSlider.setObjectName("verticalSlider")
        self.gridLayout.addWidget(self.verticalSlider, 3, 1, 1, 1)
        self.label_image = QtWidgets.QLabel(self.Result)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_image.setFont(font)
        self.label_image.setObjectName("label_image")
        self.gridLayout.addWidget(self.label_image, 2, 0, 1, 1)
        self.Mapping = QtWidgets.QWidget(self.Result)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.Mapping.sizePolicy().hasHeightForWidth())
        self.Mapping.setSizePolicy(sizePolicy)
        self.Mapping.setObjectName("Mapping")
        self.gridLayout.addWidget(self.Mapping, 3, 0, 1, 1)

        self.figure_map = Figure()
        self.canvas_map = FigureCanvas(self.figure_map)
        self.toolbar_map = NavigationToolbar(self.canvas_map, self.Result, coordinates=False)
        self.mappingbox = QtWidgets.QVBoxLayout(self.Mapping)
        self.mappingbox.addWidget(self.toolbar_map)
        self.mappingbox.addWidget(self.canvas_map)

        self.tabWidget.addTab(self.Result, "")
        self.tabWidget.addTab(self.MLResult, "")
        self.Detail_info = QtWidgets.QWidget()
        self.Detail_info.setObjectName("Detail_info")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.Detail_info)
        self.gridLayout_2.setObjectName("gridLayout_2")

        self.detail_result_info = QtWidgets.QTableWidget(self.Detail_info)
        self.detail_result_info.setObjectName("detail_result_info")
        self.detail_result_info.setColumnCount(4)
        self.detail_result_info.setRowCount(4)
        self.detail_result_info.setHorizontalHeaderLabels(['X', 'Y', 'matching factor', '미세플라스틱 종류'])
        self.gridLayout_2.addWidget(self.detail_result_info, 0, 0, 1, 1)
        self.detailedspectrum = QtWidgets.QWidget(self.Detail_info)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.detailedspectrum.sizePolicy().hasHeightForWidth())
        self.detailedspectrum.setSizePolicy(sizePolicy)
        self.detailedspectrum.setMinimumSize(QtCore.QSize(0, 0))
        self.detailedspectrum.setSizeIncrement(QtCore.QSize(0, 0))
        self.detailedspectrum.setBaseSize(QtCore.QSize(0, 0))
        self.detailedspectrum.setObjectName("detailedspectrum")
        self.gridLayout_2.addWidget(self.detailedspectrum, 0, 2, 1, 1)

        self.figure_spectrum_detailed = Figure(figsize=(6,15))
        self.canvas_spectrum_detailed = FigureCanvas(self.figure_spectrum_detailed)
        self.toolbar_spectrum_detailed = NavigationToolbar(self.canvas_spectrum_detailed, self.Detail_info, coordinates=False)


        self.spectrumbox_detailed = QtWidgets.QVBoxLayout(self.detailedspectrum)
        self.spectrumbox_detailed.addWidget(self.toolbar_spectrum_detailed)
        self.spectrumbox_detailed.addWidget(self.canvas_spectrum_detailed)

        self.scroll_area = QtWidgets.QScrollArea(self.Detail_info)
        self.gridLayout_2.addWidget(self.scroll_area, 0, 2, 1, 1)
        self.scroll_area.setWidget(self.detailedspectrum)

        self.tabWidget.addTab(self.Detail_info, "")
        self.gridLayout_3.addWidget(self.tabWidget, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1133, 21))
        self.menubar.setObjectName("menubar")
        self.menuSearch = QtWidgets.QMenu(self.menubar)
        self.menuSearch.setObjectName("menuSearch")
        self.menuCreate_map = QtWidgets.QMenu(self.menuSearch)
        self.menuCreate_map.setObjectName("menuCreate_map")
        self.menuExport = QtWidgets.QMenu(self.menuSearch)
        self.menuExport.setObjectName("menuExport")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionShow_spectrum = QtWidgets.QAction(MainWindow)
        self.actionShow_spectrum.setObjectName("actionShow_spectrum")
        self.actionCreate_cosine_map = QtWidgets.QAction(MainWindow)
        self.actionCreate_cosine_map.setObjectName("actionCreate_cosine_map")
        self.actionCreate_cosine_map.triggered.connect(self.createcosmap)
        self.actionCreate_Correlation_map = QtWidgets.QAction(MainWindow)
        self.actionCreate_Correlation_map.setObjectName("actionCreate_Correlation_map")
        self.actionCreate_Correlation_map.triggered.connect(self.createcorrmap)
        self.actionCreate_ML_map = QtWidgets.QAction(MainWindow)
        self.actionCreate_ML_map.setObjectName("actionCreate_Correlation_map")
        self.actionCreate_ML_map.triggered.connect(self.createmlmap)
        self.actionResult_information = QtWidgets.QAction(MainWindow)
        self.actionResult_information.setObjectName("actionResult_information")
        self.actionResult_information.triggered.connect(self.exportToExcel)
        self.actionDetail_result_information = QtWidgets.QAction(MainWindow)
        self.actionDetail_result_information.triggered.connect(self.exportToExceldetail)
        self.actionDetail_result_information.setObjectName("actionDetail_result_information")
        self.menuCreate_map.addAction(self.actionCreate_cosine_map)
        self.menuCreate_map.addAction(self.actionCreate_Correlation_map)
        self.menuCreate_map.addAction(self.actionCreate_ML_map)
        self.menuExport.addAction(self.actionResult_information)
        self.menuExport.addAction(self.actionDetail_result_information)
        self.menuSearch.addAction(self.menuCreate_map.menuAction())
        self.menuSearch.addAction(self.actionShow_spectrum)
        self.menuSearch.addAction(self.menuExport.menuAction())
        self.menubar.addAction(self.menuSearch.menuAction())

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def createmlmap(self):
        lggMd.LogObj.info('Enter createmlmap')
    #기존 map처럼 데이터 빼오기
        global refspec_new, map_df, cos, wn, out_img, XPos, YPos, XPoint, YPoint, Radius, val
        XPos, YPos, spec, wn = self.datapreprocess()
        QtWidgets.QMessageBox.information(None, 'Information', 'folder complete!')
        XPos_df = pd.DataFrame(XPos)
        YPos_df = pd.DataFrame(YPos)
        Pos_df = pd.concat([XPos_df, YPos_df], axis=1)
        Pos_df.columns = ['X', 'Y']
        spec_list = [pd.DataFrame(spec[i]).T for i in range(len(spec))]
        spec_df = pd.concat([spec_list[i] for i in range(len(spec_list))])
        spec_df.columns = list(wn[0])
        spec_df.index = list(range(len(spec_list)))
        map_df = pd.concat([Pos_df, spec_df], axis=1)
        
        #스케일링>모델에 넣고 돌리기>결과 출력
        map_data = map_df.values
        Input_spectrum = map_data[:, 2:]
        map_X = map_data[:, 0]
        map_Y = map_data[:,1]

        Scaler = load(open('./0615scaler.pkl', 'rb'))
        input_spectrum_scaled = Scaler.transform(Input_spectrum)

        model = keras.models.load_model('./model0615.h5')
        map_predict = model.predict(input_spectrum_scaled)
        map_predict1 = np.argmax(map_predict, axis=1)

        # top = cm.get_cmap('jet', 256) 
        # bottom = cm.get_cmap('jet', 256)
        # newcolors = np.vstack((top(np.linspace(0.1, 0.1, 128)),bottom(np.linspace(0.1, 1, 256))))
        # newjet = ListedColormap(newcolors, name='newjet')

        self.figure_map_ml.clear()

        ax = self.figure_map_ml.subplots()
        im = ax.tricontourf(XPos, YPos, map_predict1, levels=12, cmap='jet')

        ax.set_axis_off()

        self.figure_map_ml.tight_layout(pad=0)
        #self.figure_map_ml.colorbar(im)

        self.canvas_map_ml.draw()

        maptonpml = get_img_from_fig(self.figure_map_ml)
        print(maptonpml)

        map_predict2 = np.where(map_predict1 < 10, 1, map_predict1)
        map_predict2 = np.where(map_predict1 >= 10, 0, map_predict2)

        h, w, c = maptonpml.shape

        self.figure_map_ml.clear()
        ax2 = self.figure_map_ml.subplots()

        ax2.tricontourf(XPos, YPos, map_predict2, levels=12, cmap='jet')

        ax2.set_axis_off()

        self.figure_map_ml.tight_layout(pad=0)  # pad=0

        self.canvas_map_ml.draw()

        maptonpoverml = get_img_from_fig(self.figure_map_ml)
        print(maptonpoverml)  # ndarray

        gray = cv2.cvtColor(maptonpoverml, cv2.COLOR_BGR2GRAY)
        imh, imw = gray.shape
        print(gray)
        
        ret3, th3 = cv2.threshold(gray, 120, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)

        contours, hier = cv2.findContours(th3.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        out_img_ml = maptonpml.copy()  # 이것은 ndarray

        XPoint = []
        YPoint = []
        Radius =[]
        Area = []
        Width_rect = []
        Length_rect = []

        for i in range(len(contours)):
            # if hier[0][i][3] != -1:
            # continue

            (x, y), r = cv2.minEnclosingCircle(contours[i])
            a, b, w, h = cv2.boundingRect(contours[i])
            area = cv2.contourArea(contours[i])
            if area >= 50 and area < 100: # area, circle, puttext를 gui상에서 조절할 수 있을까?
                cv2.circle(out_img_ml, (int(x), int(y)), int(r), (0, 255, 255), 2)
                #cv2.putText(out_img_ml, str(i + 1), (int(x) - 5, int(y) - 10), cv2.FONT_HERSHEY_COMPLEX_SMALL, 
                            #2, (255, 127, 0))
                XPoint.append(x)
                YPoint.append(y)
                Radius.append(r)
                Area.append(area)
                Width_rect.append(w)
                Length_rect.append(h)

        ho, wo, co = out_img_ml.shape
        #self.MLresult_info.setRowCount(len(XPoint))

        self.figure_map_ml.clear()
        ax3 = self.figure_map_ml.subplots()

        im2 = ax3.imshow(out_img_ml, extent=[np.min(map_X), np.max(map_X), np.min(map_Y), np.max(map_Y)])
        im2.format_cursor_data = lambda e: ""
        
        self.figure_map_ml.tight_layout(pad=0)
        self.figure_map_ml.colorbar(im) 
        #MatplotlibDeprecationWarning: Starting from Matplotlib 3.6, colorbar() will steal space from the mappable's axes, rather than from the current axes, to place the colorbar.  To silence this warning, explicitly pass the 'ax' argument to colorbar().

        self.canvas_map_ml.draw()

        cursor_ml = mplcursors.cursor(im2, hover=False)
        #cursor_ml.connect('add', self.show_annotation_ml)
        print(out_img_ml)

        print(XPoint)
        print(XPoint[0])
        
        print(YPoint)
        print(YPoint[0])

        print(len(XPoint))
        
        # # 이제 contour 정보로 dataframe 만들고 gui에 띄우기
        # 보정 부분 바꾸기

        # A = [0, wo] # 0부터 wo까지 간격 1인 리스트
        # B = [min(map_X), max(map_X)]
         # 중복값 뺀 리스트 np.unique(XPos)

        # linear_modelX = np.polyfit(A, B, 1)
        # linear_modelX_fn = np.poly1d(linear_modelX)

        # Xposparticle = []

        # for i in range(len(XPoint)):
        #    Xposparticle.append(linear_modelX_fn(XPoint[i]))
        
        # print(Xposparticle)
        # Xposparticle_alter = Xposparticle.copy()

        # C = [ho, 0]
        # D = [min(map_Y), max(map_Y)]

        # linear_modelY = np.polyfit(C, D, 1)
        # linear_modelY_fn = np.poly1d(linear_modelY)

        # Yposparticle = []
        

        # for i in range(len(YPoint)):
        #     Yposparticle.append(linear_modelY_fn(YPoint[i]))
        
        # print(Yposparticle)
        # Yposparticle_alter = Yposparticle.copy()

        # def find_nearest(array, value):  # 가장 가까운 예상값 구하기. 
        #     array = np.asarray(array)
        #     idx = (np.abs(array - value)).argmin()
        #     return array[idx]

        # def find_second_near(array, value):
        #     array = np.asarray(array)
        #     L = list(np.abs(array - value))
        #     sorted_list = sorted(L)

        #     for i in range(len(sorted_list)):
        #         if sorted_list[i] != sorted_list[0]:
        #             second_smallest = sorted_list[i] #loop 정지시키기
        #             break

        #     min2 = L.index(second_smallest)

        #     return array[min2]
        

        # for q in range(len(Xposparticle)):
        #     Xposparticle[q] = find_nearest(XPos, Xposparticle[q])
        #     Xposparticle_alter[q] = find_second_near(XPos, Xposparticle[q])
        

        # for q in range(len(Yposparticle)):
        #     Yposparticle[q] = find_nearest(YPos, Yposparticle[q])
        #     Yposparticle_alter[q] = find_second_near(YPos, Yposparticle[q])
        
        
        # cos_factor = []

        # for r in range(len(Xposparticle)): #여러 분면에서 이부분이 문제. 
        #     #가까운 예상값들 여러 개를 찾아야
        # #     # X좌표값 위치 찾기
        #     xval = np.where(XPos == Xposparticle[r])
        #     xval2 = np.where(XPos == Xposparticle_alter[r])
            
        # #     # Y좌표값 위치 찾기
        #     yval = np.where(YPos == Yposparticle[r])
        #     yval2 = np.where(YPos == Yposparticle_alter[r])
            
        
        #      # (X,Y) 위치 찾기 # 여러 분면에서 겹치는 값 x. 주변부만 이럼. 좌표계 통일해야?
             
        #     if np.intersect1d(xval, yval).size > 0:
        #         val = np.intersect1d(xval, yval)[0]
        #         #겹치는 값 없으면 두번째 근접값 찾아야 함. 
        #     elif np.intersect1d(xval, yval2).size > 0:
        #         val = np.intersect1d(xval, yval2)[0]
        #     elif np.intersect1d(xval2, yval).size > 0:
        #         val = np.intersect1d(xval2, yval)[0]
        #     elif np.intersect1d(xval2, yval2).size > 0:
        #         val = np.intersect1d(xval2, yval2)[0]
        #     else:
        #         val = 0
        #         #val = np.intersect1d(xval3, yval3)[0]
        # #     # 해당 위치의 cos 유사도 찾기
        #     cos_factor.append(cos[val])
            
        #for j in range(len(XPoint)):
            #self.MLresult_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(Xposparticle[j])))
            #self.MLresult_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(Yposparticle[j])))
            #self.MLresult_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(Width_rect[j])))
            #self.MLresult_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(Length_rect[j])))
            #self.MLresult_info.setItem(j, 4, QtWidgets.QTableWidgetItem(str(Area[j])))
            #self.MLresult_info.setItem(j, 5, QtWidgets.QTableWidgetItem(str(cos_factor[j])))
            #self.MLresult_info.setItem(j, 5, QtWidgets.QTableWidgetItem(str(cos_factor[j])))
        #self.result_info.cellClicked.connect(self.tablecellclickedcos)
        
        # 이제 기본 스펙트럼 전시(기본값) 기본의 기준은?

        
        self.figure_spectrum_ml.clear()
        
        ax4 = self.figure_spectrum_ml.subplots()
        ax4.plot(wn[0], spec[0], label="Sample spectrum at specific point")
        ax4.invert_xaxis()
        ax4.legend(loc='best')
        ax4.xaxis.set_major_locator(MultipleLocator(500)) 
        ax4.xaxis.set_minor_locator(MultipleLocator(100)) 
        ax4.text(2000, 0.9, 'Matching score(probability): ') # class 확률에 해당하는 값 넣기
        
        self.figure_spectrum_ml.tight_layout()
        
        self.canvas_spectrum_ml.draw()
        

    def change_value(self, value):
        global val
        lggMd.LogObj.info('Enter change_value')
        self.thresholdvalue = self.label_slider.setText((str(value)))
        self.thresholdvalue = value if self.thresholdvalue is None else self.thresholdvalue
        print(self.thresholdvalue)
        print(type(self.thresholdvalue))
        if 'cos' in globals():
            value = cos
            valuemin = np.min(cos)
            valuemax = np.max(cos)
        elif 'corr' in globals():
            value = corr
            valuemin = np.min(corr)
            valuemax = np.max(corr)
        else:
            error_dialog = QtWidgets.QErrorMessage()
            error_message = traceback.format_exc()  # 요걸 다이알로그에 띄워야 함
            error_dialog.showMessage(str(error_message))
            error_dialog.resize(380, 150)
            error_dialog.exec_() 
        self.thershold = (self.thresholdvalue/ 100) * (valuemax - valuemin) + valuemin 
        print(self.thershold)
        print(type(self.thershold))
        self.label_slider.setText((str(round(self.thershold, 3))))

        value_over = np.where(value < self.thershold, 0.0, value)
        value_over = np.where(value_over >= self.thershold, 1.0, value_over)
        print(value_over)

        top = cm.get_cmap('jet', 256) 
        bottom = cm.get_cmap('jet', 256)
        newcolors = np.vstack((top(np.linspace(0.1, 0.1, 128)),bottom(np.linspace(0.1, 1, 256))))
        newjet = ListedColormap(newcolors, name='newjet')

        self.figure_map.clear()

        ax = self.figure_map.subplots()
        im = ax.tricontourf(XPos, YPos, value, levels=100, cmap=newjet)

        ax.set_axis_off()

        self.figure_map.tight_layout(pad=0)

        self.canvas_map.draw()

        maptonp = get_img_from_fig(self.figure_map)
        print(maptonp)

        h, w, c = maptonp.shape


        ax.tricontourf(XPos, YPos, value_over, levels=100, cmap=newjet)

        ax.set_axis_off()

        self.figure_map.tight_layout(pad=0)  # pad=0

        self.canvas_map.draw()

        maptonpover = get_img_from_fig(self.figure_map)
        print(maptonpover)  # ndarray

        gray = cv2.cvtColor(maptonpover, cv2.COLOR_BGR2GRAY)
        imh, imw = gray.shape
        print(gray)
        
        ret3, th3 = cv2.threshold(gray, 120, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

        contours, hier = cv2.findContours(th3.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        out_img = maptonp.copy()  # 이것은 ndarray

        XPoint = []
        YPoint = []
        Radius =[]
        Area = []
        Width_rect = []
        Length_rect = []

        for i in range(len(contours)):
            # if hier[0][i][3] != -1:
            # continue

            (x, y), r = cv2.minEnclosingCircle(contours[i])
            a, b, w, h = cv2.boundingRect(contours[i])
            area = cv2.contourArea(contours[i])
            if area >= 0 and area < 100:
                cv2.circle(out_img, (int(x), int(y)), int(r), (255, 127, 0), 2)
                cv2.putText(out_img, str(i + 1), (int(x) - 5, int(y) - 10), cv2.FONT_HERSHEY_COMPLEX_SMALL, 
                            2, (255, 127, 0))
                XPoint.append(x)
                YPoint.append(y)
                Radius.append(r)
                Area.append(area)
                Width_rect.append(w)
                Length_rect.append(h)

        ho, wo, co = out_img.shape
        self.result_info.setRowCount(len(XPoint))

        self.figure_map.clear()
        ax2 = self.figure_map.subplots()

        im2 = ax2.imshow(out_img, extent=[np.min(XPos), np.max(XPos), np.min(YPos), np.max(YPos)])
        im2.format_cursor_data = lambda e: ""
        
        self.figure_map.tight_layout(pad=0)
        self.figure_map.colorbar(im) 
        #MatplotlibDeprecationWarning: Starting from Matplotlib 3.6, colorbar() will steal space from the mappable's axes, rather than from the current axes, to place the colorbar.  To silence this warning, explicitly pass the 'ax' argument to colorbar().

        self.canvas_map.draw()
        
        cursor = mplcursors.cursor(im2, hover=False)
        if 'cos' in globals():
            cursor.connect('add', self.show_annotation_cos)
        elif 'corr' in globals():
            cursor.connect('add', self.show_annotation_corr)
        print(out_img)

        A = [0, wo]
        B = [np.min(XPos), np.max(XPos)]

        linear_modelX = np.polyfit(A, B, 1)
        linear_modelX_fn = np.poly1d(linear_modelX)

        Xposparticle = []
        
        for i in range(len(XPoint)):
           Xposparticle.append(linear_modelX_fn(XPoint[i]))

        Xposparticle_alter = Xposparticle.copy()


        C = [ho, 0]
        D = [np.min(YPos), np.max(YPos)]

        linear_modelY = np.polyfit(C, D, 1)
        linear_modelY_fn = np.poly1d(linear_modelY)

        Yposparticle = []
        

        for i in range(len(YPoint)):
            Yposparticle.append(linear_modelY_fn(YPoint[i]))
        
        Yposparticle_alter = Yposparticle.copy()

        for q in range(len(Xposparticle)):
            Xposparticle[q] = find_nearest(XPos, Xposparticle[q])
            Xposparticle_alter[q] = find_second_near(XPos, Xposparticle[q])
        

        for q in range(len(Yposparticle)):
            Yposparticle[q] = find_nearest(YPos, Yposparticle[q])
            Yposparticle_alter[q] = find_second_near(YPos, Yposparticle[q])
        
        factor = []

        for r in range(len(Xposparticle)): #여러 분면에서 이부분이 문제. 
            #가까운 예상값들 여러 개를 찾아야
        #     # X좌표값 위치 찾기
            xval = np.where(XPos == Xposparticle[r])
            xval2 = np.where(XPos == Xposparticle_alter[r])            
        #     # Y좌표값 위치 찾기
            yval = np.where(YPos == Yposparticle[r])
            yval2 = np.where(YPos == Yposparticle_alter[r])
         # (X,Y) 위치 찾기 겹치는 값 없으면 두번째 근접값 찾아야 함. 
             
            if np.intersect1d(xval, yval).size > 0:
                val = np.intersect1d(xval, yval)[0] 
            elif np.intersect1d(xval, yval2).size > 0:
                val = np.intersect1d(xval, yval2)[0]
            elif np.intersect1d(xval2, yval).size > 0:
                val = np.intersect1d(xval2, yval)[0]
            elif np.intersect1d(xval2, yval2).size > 0:
                val = np.intersect1d(xval2, yval2)[0]
            else:
                val = 0
                #val = np.intersect1d(xval3, yval3)[0]
            
            factor.append(value[val])
        
        if 'cos' in globals():
            self.result_info.setHorizontalHeaderLabels(['X', 'Y', 'width', 'length', 'area', 'matching factor\n(cosine similarity)'])
        elif 'corr' in globals():
            self.result_info.setHorizontalHeaderLabels(['X', 'Y', 'width', 'length', 'area', 'matching factor\n(Correlation coefficient)'])    
        for j in range(len(XPoint)):
            self.result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(Xposparticle[j])))
            self.result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(Yposparticle[j])))
            self.result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(Width_rect[j])))
            self.result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(Length_rect[j])))
            self.result_info.setItem(j, 4, QtWidgets.QTableWidgetItem(str(Area[j])))
            self.result_info.setItem(j, 5, QtWidgets.QTableWidgetItem(str(factor[j])))
        if 'cos' in globals():
            self.result_info.cellClicked.connect(self.tablecellclickedcos)
        elif 'corr' in globals():
            self.result_info.cellClicked.connect(self.tablecellclickedcorr)

    def datapreprocess(self):  # 폴더 속 spa들에서 포인트값과 스펙트럼 정보 가져오기. 글로벌변수(?)
        #global PosX, PosY, spec, wn
        lggMd.LogObj.info('datapreprocess Entry')

        self.file_dialog = QtWidgets.QFileDialog()
        self.file_dialog.setFileMode(QtWidgets.QFileDialog.DirectoryOnly)
        self.file_dialog.setOption(QtWidgets.QFileDialog.DontUseNativeDialog, True)
        self.file_view = self.file_dialog.findChild(QtWidgets.QListView, 'listview')

        if self.file_view:
            self.file_view.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        self.f_tree_view = self.file_dialog.findChild(QtWidgets.QTreeView)
        if self.f_tree_view:
            self.f_tree_view.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)

        if self.file_dialog.exec():
            folderpaths = self.file_dialog.selectedFiles()
        folderpaths1 = folderpaths[1:]
        if len(folderpaths1) == 1: #폴더가 하나인 경우
            file_list = os.listdir(folderpaths1[0])  # 단수면 이대로. 복수면 list comprehension
            file_name = [folderpaths1[0] + '/' + file_list[j] for j in range(len(file_list))]
        #folderpath = QtWidgets.QFileDialog.getExistingDirectory(None, 'Select Folder')
        # 타입 str. 복수 폴더는 how?
        elif len(folderpaths1) > 1 : #복수 폴더인 경우
            path = [folderpaths1[i] + '/*' for i in range(len(folderpaths1))] #여러 path 해야 함
            file_list = [glob.glob(path[i]) for i in range(len(path))] 
            file_name_raw = [file for file in file_list]
            file_name = sum(file_name_raw, [])   
        else:
            None # 에러메시지 생성. 내용은 'Choose folder!'
        
        lggMd.LogObj.info(f'file_name cnt: {len(file_name)}')
        
        globalValue.InitProgressDia()
        globalValue.proDlg.SetIncreate(-1)
        globalValue.proDlg.SetAllCnt(int(len(file_name)));

        thread = ThreadFileRead.FileReadWorker();
        
        thread.SetFile(file_name)
        thread.run()
        lggMd.LogObj.info('File Read Success')

        spec = [np.round(globalValue.results[i][0],2) for i in range(len(globalValue.results))]
        wn = [globalValue.results[i][1] for i in range(len(globalValue.results))]
        tit = [globalValue.results[i][2] for i in range(len(globalValue.results))]
        #spec = np.asarray(spec)
        #wn = np.asarray(wn)
        #tit = list(tit)

        #tit에서 X, Y 정보 빼내기
        PosX = [float(re.findall(r'-?\d+\.\d*', tit[i])[-2]) for i in range(len(tit))]
        PosY = [float(re.findall(r'-?\d+\.\d*', tit[i])[-1]) for i in range(len(tit))]
        PosX = np.asarray(PosX)
        PosY = np.asarray(PosY)
        #print(PosX)
        return PosX, PosY, spec, wn

    # 전처리 소요 시간 3~4분(파일은 약 6만여개)

    def refpreprocess(self):
        lggMd.LogObj.info('Enter refpreprocess')
        file = QtWidgets.QFileDialog.getOpenFileName(None, 'select reference')
        fname, ext = os.path.splitext(file[0])
        print(fname)
        print(ext)
        if ext == '.SPA':
            refspec, refwn, reftit = Wrap_asyncIo.read_spa(file[0])
            # print(refspec)  # 여기에 read_spa 써서 ref 전처리
            if isclose(refspec.max(), 1.0, abs_tol=1e-3) and isclose(refspec.min(), 0, abs_tol=1e-3):
                refspec = round(refspec, 2)
            else:
                refspec = round((refspec - np.min(refspec)) / (np.max(refspec) - np.min(refspec)), 2)

            fq = interp1d(refwn, refspec, kind='cubic', fill_value="extrapolate")
            wn = self.datapreprocess()[3]  # 다시 부르기 번거로워. 이전 값을 재사용하고 싶음
            refspec_new = fq(wn[0])

        elif ext == '.csv':
            ref = pd.read_csv(file[0], header=None, names=['wavenumber', 'Absorbance'])
            ref = ref.drop_duplicates(['wavenumber'])
            refwn = ref.iloc[:, 0].values
            refspec = ref.iloc[:, 1].values
            if isclose(refspec.max(), 1.0, abs_tol=1e-3) and isclose(refspec.min(), 0, abs_tol=1e-3):
                refspec = round(refspec, 2)
            else:
                refspec = round((refspec - np.min(refspec)) / (np.max(refspec) - np.min(refspec)), 2)
            fq = interp1d(refwn, refspec, kind='cubic', fill_value="extrapolate")
            wn = self.datapreprocess()[3]  # 다시 부르기 번거로워. 이전 값을 재사용하고 싶음
            refspec_new = fq(wn[0])

        return refspec_new

    def createcosmap(self):
        lggMd.LogObj.info('Enter createcosmap')
        global refspec_new, map_df, cos, wn, out_img, XPos, YPos, XPoint, YPoint, Radius, val
        XPos, YPos, spec, wn = self.datapreprocess()
        QtWidgets.QMessageBox.information(None, 'Information', 'folder complete!')
        XPos_df = pd.DataFrame(XPos)
        YPos_df = pd.DataFrame(YPos)
        Pos_df = pd.concat([XPos_df, YPos_df], axis=1)
        Pos_df.columns = ['X', 'Y']
        spec_list = [pd.DataFrame(spec[i]).T for i in range(len(spec))]
        spec_df = pd.concat([spec_list[i] for i in range(len(spec_list))])
        spec_df.columns = list(wn[0])
        spec_df.index = list(range(len(spec_list)))
        map_df = pd.concat([Pos_df, spec_df], axis=1)

        file = QtWidgets.QFileDialog.getOpenFileName(None, 'select reference')
        fname, ext = os.path.splitext(file[0])
        print(fname)
        fnames = fname.split('/')
        print(fnames[-1])
        print(ext)
        if ext == '.SPA':
            refspec, refwn, reftit = Wrap_asyncIo.read_spa(file[0])
            fq = interp1d(refwn, refspec, kind='cubic', fill_value="extrapolate")
            refspec_new = fq(wn[0])
            # print(refspec)  # 여기에 read_spa 써서 ref 전처리
            if isclose(refspec_new.max(), 1.0, abs_tol=1e-3) and isclose(refspec_new.min(), 0, abs_tol=1e-3):
                refspec_new = np.round(refspec_new, 2)
            else:
                refspec_new = np.round((refspec_new - np.min(refspec_new)) / (np.max(refspec_new) - np.min(refspec_new)), 2)

        elif ext == '.csv':
            ref = pd.read_csv(file[0], header=None, names=['wavenumber', 'Absorbance'])
            ref = ref.drop_duplicates(['wavenumber'])
            refwn = ref.iloc[:, 0].values
            refspec = ref.iloc[:, 1].values
            fq = interp1d(refwn, refspec, kind='cubic', fill_value="extrapolate")
            refspec_new = fq(wn[0])
            if isclose(refspec_new.max(), 1.0, abs_tol=1e-3) and isclose(refspec_new.min(), 0, abs_tol=1e-3):
                refspec_new = np.round(refspec_new, 2)
            else:
                refspec_new = np.round((refspec_new - np.min(refspec_new)) / (np.max(refspec_new) - np.min(refspec_new)), 2)

        cos = [np.round(np.round(np.dot(refspec_new, spec[i]) / (np.linalg.norm(refspec_new) * np.linalg.norm(spec[i])), 2), 2)
               if np.linalg.norm(spec[i]) != 0 else 0 for i in range(len(spec))]
        cos = np.asarray(cos)

        cosmin = np.min(cos)
        cosmax = np.max(cos)
        print(cosmin)
        print(cosmax)
        self.label_info.setText('Result information (Metric: cosine similarity, Reference: {})'.format(fnames[-1]))
        th_slider = self.verticalSlider.value() / 100
        th_cos = th_slider * (cosmax - cosmin) + cosmin
        print(th_slider)
        print(th_cos)
        self.label_slider.setText((str(th_cos)))
       
        cos_over = np.where(cos < th_cos, 0.0, cos)
        cos_over = np.where(cos_over >= th_cos, 1.0, cos_over)
        print(cos_over)
        
        top = cm.get_cmap('jet', 256) 
        bottom = cm.get_cmap('jet', 256)
        newcolors = np.vstack((top(np.linspace(0.1, 0.1, 128)),bottom(np.linspace(0.1, 1, 256))))
        newjet = ListedColormap(newcolors, name='newjet')

        self.figure_map.clear()

        ax = self.figure_map.subplots()
        im = ax.tricontourf(XPos, YPos, cos, levels=100, cmap=newjet)

        ax.set_axis_off()

        self.figure_map.tight_layout(pad=0)

        self.canvas_map.draw()

        maptonp = get_img_from_fig(self.figure_map)
        print(maptonp)

        h, w, c = maptonp.shape

        ax.tricontourf(XPos, YPos, cos_over, levels=100, cmap=newjet)

        ax.set_axis_off()

        self.figure_map.tight_layout(pad=0)  # pad=0

        self.canvas_map.draw()

        maptonpover = get_img_from_fig(self.figure_map)
        print(maptonpover)  # ndarray

        gray = cv2.cvtColor(maptonpover, cv2.COLOR_BGR2GRAY)
        imh, imw = gray.shape
        print(gray)
        
        ret3, th3 = cv2.threshold(gray, 120, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

        contours, hier = cv2.findContours(th3.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        out_img = maptonp.copy()  # 이것은 ndarray

        XPoint = []
        YPoint = []
        Radius =[]
        Area = []
        Width_rect = []
        Length_rect = []

        for i in range(len(contours)):
            if hier[0][i][3] != -1:
                continue

            (x, y), r = cv2.minEnclosingCircle(contours[i])
            a, b, w, h = cv2.boundingRect(contours[i])
            area = cv2.contourArea(contours[i])
            if area >= 0 and area < 100:
                cv2.circle(out_img, (int(x), int(y)), int(r), (255, 127, 0), 2)
                cv2.putText(out_img, str(i + 1), (int(x) - 5, int(y) - 10), cv2.FONT_HERSHEY_COMPLEX_SMALL, 
                            2, (255, 127, 0))
                XPoint.append(x)
                YPoint.append(y)
                Radius.append(r)
                Area.append(area)
                Width_rect.append(w)
                Length_rect.append(h)
        

        ho, wo, co = out_img.shape

        
        self.result_info.setRowCount(len(XPoint))

        self.figure_map.clear()
        ax2 = self.figure_map.subplots()

        im2 = ax2.imshow(out_img, extent=[np.min(XPos), np.max(XPos), np.min(YPos), np.max(YPos)])
        im2.format_cursor_data = lambda e: ""
                
        self.figure_map.tight_layout(pad=0)
        self.figure_map.colorbar(im)
        
        #MatplotlibDeprecationWarning: Starting from Matplotlib 3.6, colorbar() will steal space from the mappable's axes, rather than from the current axes, to place the colorbar.  To silence this warning, explicitly pass the 'ax' argument to colorbar().

        self.canvas_map.draw()
        
        cursor = mplcursors.cursor(im2, hover=False)
        cursor.connect('add', self.show_annotation_cos)
        print(out_img)

        print(XPoint)
        print(XPoint[0])
        print(XPos)
        print(YPoint)
        print(YPoint[0])
        print(YPos)
        # # 이제 contour 정보로 dataframe 만들고 gui에 띄우기
        # 보정 부분 바꾸기

        A = [0, wo] # 0부터 wo까지 간격 1인 리스트
        B = [min(XPos), max(XPos)]
         # 중복값 뺀 리스트 np.unique(XPos)

        linear_modelX = np.polyfit(A, B, 1)
        linear_modelX_fn = np.poly1d(linear_modelX)

        Xposparticle = []

        for i in range(len(XPoint)):
           Xposparticle.append(linear_modelX_fn(XPoint[i]))
        
        print(Xposparticle)
        Xposparticle_alter = Xposparticle.copy()

        C = [ho, 0]
        D = [min(YPos), max(YPos)]

        linear_modelY = np.polyfit(C, D, 1)
        linear_modelY_fn = np.poly1d(linear_modelY)

        Yposparticle = []
        

        for i in range(len(YPoint)):
            Yposparticle.append(linear_modelY_fn(YPoint[i]))
        
        print(Yposparticle)
        Yposparticle_alter = Yposparticle.copy()

        def find_nearest(array, value):  # 가장 가까운 예상값 구하기. 
            array = np.asarray(array)
            idx = (np.abs(array - value)).argmin()
            return array[idx]

        def find_second_near(array, value):
            array = np.asarray(array)
            L = list(np.abs(array - value))
            sorted_list = sorted(L)

            for i in range(len(sorted_list)):
                if sorted_list[i] != sorted_list[0]:
                    second_smallest = sorted_list[i] #loop 정지시키기
                    break

            min2 = L.index(second_smallest)

            return array[min2]
        

        for q in range(len(Xposparticle)):
            Xposparticle[q] = find_nearest(XPos, Xposparticle[q])
            Xposparticle_alter[q] = find_second_near(XPos, Xposparticle[q])
        

        for q in range(len(Yposparticle)):
            Yposparticle[q] = find_nearest(YPos, Yposparticle[q])
            Yposparticle_alter[q] = find_second_near(YPos, Yposparticle[q])
        
        
        cos_factor = []

        for r in range(len(Xposparticle)): #여러 분면에서 이부분이 문제. 
            #가까운 예상값들 여러 개를 찾아야
        #     # X좌표값 위치 찾기
            xval = np.where(XPos == Xposparticle[r])
            xval2 = np.where(XPos == Xposparticle_alter[r])
            
        #     # Y좌표값 위치 찾기
            yval = np.where(YPos == Yposparticle[r])
            yval2 = np.where(YPos == Yposparticle_alter[r])
            
        
             # (X,Y) 위치 찾기 # 여러 분면에서 겹치는 값 x. 주변부만 이럼. 좌표계 통일해야?
             
            if np.intersect1d(xval, yval).size > 0:
                val = np.intersect1d(xval, yval)[0]
                #겹치는 값 없으면 두번째 근접값 찾아야 함. 
            elif np.intersect1d(xval, yval2).size > 0:
                val = np.intersect1d(xval, yval2)[0]
            elif np.intersect1d(xval2, yval).size > 0:
                val = np.intersect1d(xval2, yval)[0]
            elif np.intersect1d(xval2, yval2).size > 0:
                val = np.intersect1d(xval2, yval2)[0]
            else:
                val = 0
                #val = np.intersect1d(xval3, yval3)[0]
        #     # 해당 위치의 cos 유사도 찾기
            cos_factor.append(cos[val])
            
        self.result_info.setHorizontalHeaderLabels(['X', 'Y', 'width', 'length', 'area', 'matching factor\n(cosine similarity)'])
        for j in range(len(XPoint)):
            self.result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(Xposparticle[j])))
            self.result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(Yposparticle[j])))
            self.result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(Width_rect[j])))
            self.result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(Length_rect[j])))
            self.result_info.setItem(j, 4, QtWidgets.QTableWidgetItem(str(Area[j])))
            self.result_info.setItem(j, 5, QtWidgets.QTableWidgetItem(str(cos_factor[j])))
        self.result_info.cellClicked.connect(self.tablecellclickedcos)
        
        # 이제 기본 스펙트럼 전시(기본값) 기본의 기준은?
        
        self.figure_spectrum.clear()
        
        ax3 = self.figure_spectrum.subplots()
        ax3.plot(wn[0], spec[0], label="Sample spectrum at specific point")
        ax3.plot(wn[0], refspec_new, label="Reference spectrum")
        ax3.invert_xaxis()
        ax3.legend(loc='best')
        ax3.xaxis.set_major_locator(MultipleLocator(500)) 
        ax3.xaxis.set_minor_locator(MultipleLocator(100)) 
        ax3.text(2000, 0.9, 'Cosine similarity: {}'.format(cos[0], 3))
        
        self.figure_spectrum.tight_layout()
        
        self.canvas_spectrum.draw()

        #표 export. GUI 상에서 ref 명시해보기

        #return XPos1, YPos1, wn1, spec1, corr, corr_over, #img, #img_over

    def createcorrmap(self):
        lggMd.LogObj.info('Enter createcorrmap')
        global refspec_new, map_df, corr, wn, out_img, XPos, YPos, XPoint, YPoint, Radius, val
        XPos, YPos, spec, wn = self.datapreprocess()
        QtWidgets.QMessageBox.information(None, 'Information', 'folder complete!')
        XPos_df = pd.DataFrame(XPos)
        YPos_df = pd.DataFrame(YPos)
        Pos_df = pd.concat([XPos_df, YPos_df], axis=1)
        Pos_df.columns = ['X', 'Y']
        spec_list = [pd.DataFrame(spec[i]).T for i in range(len(spec))]
        spec_df = pd.concat([spec_list[i] for i in range(len(spec_list))])
        spec_df.columns = list(wn[0])
        spec_df.index = list(range(len(spec_list)))
        map_df = pd.concat([Pos_df, spec_df], axis=1)
        print(map_df)
        file = QtWidgets.QFileDialog.getOpenFileName(None, 'select reference')
        fname, ext = os.path.splitext(file[0])
        print(fname)
        fnames = fname.split('/')
        print(fnames[-1])
        print(ext)
        if ext == '.SPA':
            refspec, refwn, reftit = Wrap_asyncIo.read_spa(file[0])
            fq = interp1d(refwn, refspec, kind='cubic', fill_value="extrapolate")
            refspec_new = fq(wn[0])
            # print(refspec)  # 여기에 read_spa 써서 ref 전처리
            if isclose(refspec_new.max(), 1.0, abs_tol=1e-3) and isclose(refspec_new.min(), 0, abs_tol=1e-3):
                refspec_new = np.round(refspec_new,2)
            else:
                refspec_new = np.round((refspec_new - np.min(refspec_new)) / (np.max(refspec_new) - np.min(refspec_new)), 2)
        elif ext == '.csv':
            ref = pd.read_csv(file[0], header=None, names=['wavenumber', 'Absorbance'])
            ref = ref.drop_duplicates(['wavenumber'])
            refwn = ref.iloc[:, 0].values
            refspec = ref.iloc[:, 1].values
            fq = interp1d(refwn, refspec, kind='cubic', fill_value="extrapolate")
            refspec_new = fq(wn[0])
            if isclose(refspec_new.max(), 1.0, abs_tol=1e-3) and isclose(refspec_new.min(), 0, abs_tol=1e-3):
                refspec_new = np.round(refspec_new, 2)
            else:
                refspec_new = np.round((refspec_new - np.min(refspec_new)) / (np.max(refspec_new) - np.min(refspec_new)), 2)

        corr = [np.round(np.corrcoef(refspec_new, spec[k])[0, 1], 2) 
                if np.std(spec[k]) != 0 else 0 for k in range(len(spec))]
        corr = np.asarray(corr)
        print(corr) #숫자 아닌 거 있으면 바꿔야 함. 일단 0으로
        print(corr.shape)
        corrmin = np.min(corr)
        corrmax = np.max(corr)
        self.label_info.setText('Result information (Metric: Correlation coefficient, Reference: {})'.format(fnames[-1]))
        th_slider = self.verticalSlider.value() / 100
        th_corr = th_slider * (corrmax - corrmin) + corrmin  

        self.label_slider.setText((str(th_corr)))
        corr_over = np.where(corr < th_corr, 0.0, corr)
        corr_over = np.where(corr_over >= th_corr, 1.0, corr_over)

        top = cm.get_cmap('jet', 256) 
        bottom = cm.get_cmap('jet', 256)
        newcolors = np.vstack((top(np.linspace(0.1, 0.1, 128)),bottom(np.linspace(0.1, 1, 256))))
        newjet = ListedColormap(newcolors, name='newjet')

        self.figure_map.clear()

        ax = self.figure_map.subplots()
        im = ax.tricontourf(XPos, YPos, corr, levels=100, cmap=newjet)

        ax.set_axis_off()

        self.figure_map.tight_layout(pad=0)

        self.canvas_map.draw()

        maptonp = get_img_from_fig(self.figure_map)
        print(maptonp)

        h, w, c = maptonp.shape

        ax.tricontourf(XPos, YPos, corr_over, levels=100, cmap=newjet)

        ax.set_axis_off()

        self.figure_map.tight_layout(pad=0)  

        self.canvas_map.draw()

        maptonpover = get_img_from_fig(self.figure_map)
        print(maptonpover)  

        gray = cv2.cvtColor(maptonpover, cv2.COLOR_BGR2GRAY)
        imh, imw = gray.shape
        print(gray)

        ret3, th3 = cv2.threshold(gray, 120, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

        contours, hier = cv2.findContours(th3.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        out_img = maptonp.copy()  

        XPoint = []
        YPoint = []
        Radius =[]
        Area = []
        Width_rect = []
        Length_rect = []

        for i in range(len(contours)):
            # if hier[0][i][3] != -1:
            # continue

            (x, y), r = cv2.minEnclosingCircle(contours[i])
            a, b, w, h = cv2.boundingRect(contours[i])
            area = cv2.contourArea(contours[i])
            if area >= 0 and area < 100:
                cv2.circle(out_img, (int(x), int(y)), int(r), (255, 127, 0), 2)
                cv2.putText(out_img, str(i + 1), (int(x) - 5, int(y) - 10), cv2.FONT_HERSHEY_COMPLEX_SMALL, 
                            2, (255, 127, 0))
                XPoint.append(x)
                YPoint.append(y)
                Radius.append(r)
                Area.append(area)
                Width_rect.append(w)
                Length_rect.append(h)

        ho, wo, co = out_img.shape
        self.result_info.setRowCount(len(XPoint))

        self.figure_map.clear()
        ax2 = self.figure_map.subplots()

        im2 = ax2.imshow(out_img, aspect='auto', extent=[np.min(XPos), np.max(XPos), np.min(YPos), np.max(YPos)])
        im2.format_cursor_data = lambda e: ""
        self.figure_map.tight_layout(pad=0)
        self.figure_map.colorbar(im)

        #MatplotlibDeprecationWarning: Starting from Matplotlib 3.6, colorbar() will steal space from the mappable's axes, rather than from the current axes, to place the colorbar.  To silence this warning, explicitly pass the 'ax' argument to colorbar().
        self.canvas_map.draw()

        cursor = mplcursors.cursor(im2, hover=False)
        cursor.connect('add', self.show_annotation_corr)

        print(out_img)

        A = [0, wo] # 0부터 wo까지 간격 1인 리스트
        B = [min(XPos), max(XPos)]
         # 중복값 뺀 리스트 np.unique(XPos)

        linear_modelX = np.polyfit(A, B, 1)
        linear_modelX_fn = np.poly1d(linear_modelX)

        Xposparticle = []

        for i in range(len(XPoint)):
           Xposparticle.append(linear_modelX_fn(XPoint[i]))
        
        print(Xposparticle)
        Xposparticle_alter = Xposparticle.copy()

        C = [ho, 0]
        D = [min(YPos), max(YPos)]

        linear_modelY = np.polyfit(C, D, 1)
        linear_modelY_fn = np.poly1d(linear_modelY)

        Yposparticle = []
        

        for i in range(len(YPoint)):
            Yposparticle.append(linear_modelY_fn(YPoint[i]))
        
        print(Yposparticle)
        Yposparticle_alter = Yposparticle.copy()

        for q in range(len(Xposparticle)):
            Xposparticle[q] = find_nearest(XPos, Xposparticle[q])
            Xposparticle_alter[q] = find_second_near(XPos, Xposparticle[q])
        

        for q in range(len(Yposparticle)):
            Yposparticle[q] = find_nearest(YPos, Yposparticle[q])
            Yposparticle_alter[q] = find_second_near(YPos, Yposparticle[q])
        
        
        corr_factor = []

        for r in range(len(Xposparticle)): #여러 분면에서 이부분이 문제. 
            #가까운 예상값들 여러 개를 찾아야
        #     # X좌표값 위치 찾기
            xval = np.where(XPos == Xposparticle[r])
            xval2 = np.where(XPos == Xposparticle_alter[r])
            
        #     # Y좌표값 위치 찾기
            yval = np.where(YPos == Yposparticle[r])
            yval2 = np.where(YPos == Yposparticle_alter[r])
            
        
             # (X,Y) 위치 찾기 # 여러 분면에서 겹치는 값 x. 주변부만 이럼. 좌표계 통일해야?
             
            if np.intersect1d(xval, yval).size > 0:
                val = np.intersect1d(xval, yval)[0]
                #겹치는 값 없으면 두번째 근접값 찾아야 함. 
            elif np.intersect1d(xval, yval2).size > 0:
                val = np.intersect1d(xval, yval2)[0]
            elif np.intersect1d(xval2, yval).size > 0:
                val = np.intersect1d(xval2, yval)[0]
            elif np.intersect1d(xval2, yval2).size > 0:
                val = np.intersect1d(xval2, yval2)[0]
            else:
                val = 0
        #     # 해당 위치의 corr 계수 찾기
            corr_factor.append(corr[val])
        
        #print(xval)
        #print(yval)
        #print(cos[0])
        self.result_info.setHorizontalHeaderLabels(['X', 'Y', 'width', 'length', 'area', 'matching factor\n(cosine similarity)'])
        for j in range(len(XPoint)):
            self.result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(Xposparticle[j])))
            self.result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(Yposparticle[j])))
            self.result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(Width_rect[j])))
            self.result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(Length_rect[j])))
            self.result_info.setItem(j, 4, QtWidgets.QTableWidgetItem(str(Area[j])))
            self.result_info.setItem(j, 5, QtWidgets.QTableWidgetItem(str(corr_factor[j])))
        self.result_info.cellClicked.connect(self.tablecellclickedcorr)
        # 이제 기본 스펙트럼 전시(기본값) 기본의 기준은?

        Xde = np.where(XPos == np.median(XPos))
        print(Xde[0])
        Yde = np.where(YPos == np.median(YPos))
        de = np.intersect1d(Xde[0], Yde[0])  # 요거 해결하기. 아무것도 없다?
        print(de)
        
        self.figure_spectrum.clear()
        
        ax3 = self.figure_spectrum.subplots()
        ax3.plot(wn[0], spec[0], label="Sample spectrum at specific point")
        ax3.plot(wn[0], refspec_new, label="Reference spectrum")
        ax3.xaxis.set_major_locator(MultipleLocator(500)) 
        ax3.xaxis.set_minor_locator(MultipleLocator(100))
        ax3.invert_xaxis()
        ax3.legend()
        ax3.text(2000, 0.9, 'Correlation coefficient: {}'.format(corr[0], 3))
        
        self.figure_spectrum.tight_layout()
        
        self.canvas_spectrum.draw()

        # return XPos1, YPos1, wn1, spec1, corr, corr_over, #img, #img_over

    def libraryconstruction(self):
        lggMd.LogObj.info('Enter libraryconstruction')
        refspectra = [np.load(i) for i in glob.glob(r'.\Reference\npynew\*.npy')]
        #exe로 만들 때는 파일 위치 상대로 재조정. dist에 numpy 넣기
        return refspectra

    def show_annotation_cos(self, sel):
        lggMd.LogObj.info('Enter show_annotation_cos')
        x_hovered = np.round(sel.target[0], 2)
        y_hovered = np.round(sel.target[1], 2)
        print(x_hovered, y_hovered) 

        
        x_clicked = find_nearest(map_df['X'], x_hovered)
        x_clicked2 = find_second_near(map_df['X'], x_hovered)
        y_clicked = find_nearest(map_df['Y'], y_hovered) 
        y_clicked2 = find_second_near(map_df['Y'], y_hovered)
        print(x_clicked, y_clicked)
        print(x_clicked2, y_clicked2)
        sel.annotation.set_text('X = {}, Y = {}'.format(x_clicked, y_clicked))
        condition1 = (map_df['X'] == float(x_clicked)) & (map_df['Y'] == float(y_clicked))
        condition2 = (map_df['X'] == float(x_clicked)) & (map_df['Y'] == float(y_clicked2))
        condition3 = (map_df['X'] == float(x_clicked2)) & (map_df['Y'] == float(y_clicked))
        condition4 = (map_df['X'] == float(x_clicked2)) & (map_df['Y'] == float(y_clicked2))
        if map_df[condition1].iloc[:,2:].empty == False:
            spectra_item = map_df[condition1].iloc[:,2:]
        elif map_df[condition2].iloc[:,2:].empty == False:
            spectra_item = map_df[condition2].iloc[:,2:]
        elif map_df[condition3].iloc[:,2:].empty == False:
            spectra_item = map_df[condition3].iloc[:,2:]
        elif map_df[condition4].iloc[:,2:].empty == False:
            spectra_item = map_df[condition4].iloc[:,2:]
        else:
            spectra_item = map_df[0].iloc[:,2:]
        print(spectra_item) 
        print(spectra_item.index[0])
       
        self.figure_spectrum.clear()
        
        ax3 = self.figure_spectrum.subplots()
        ax3.plot(spectra_item.columns.to_list(), spectra_item.T.values.tolist(), label="Sample spectrum at specific point")
        ax3.plot(wn[0], refspec_new, label="Reference spectrum")
        ax3.invert_xaxis()
        ax3.legend(loc=1)
        ax3.xaxis.set_major_locator(MultipleLocator(500)) 
        ax3.xaxis.set_minor_locator(MultipleLocator(100))
        ax3.text(1490, 0.8, 'Cosine Similarity: {}'.format(cos[spectra_item.index[0]], 3))
        
        self.figure_spectrum.tight_layout()

        self.canvas_spectrum.draw() 

        ref_list = self.libraryconstruction()
        #불러온 ref list와 스펙트럼 계산하기

        spectra_item_re = spectra_item.T.values.tolist()
        name = ['Acrylic', 'Alkyd', 'Cellulose acetate trimellitate', 'Cellulose acetate', 'CSP_stryene acrylate_', 'epoxy resin ester', 
        'Ethylene acrylic acid', 'Ethylene ethyl acrylate copolymer', 'ethylene vinyl acetate copolymer', 'ethylene vinyl acetate polymer',
        'Ethylene Vinyl Acetate', 'ethylene_propylene', 'HDPE', 'LDPE', 'NYLON', 'PB', 'PE-co-methacrylic acid', 'Phenoxy resin',
        'PMMA', 'PET', 'PS', 'Polyacetal', 'Polyalkene', 'Polyamide', 'polybutylene terephthalate', 'Polycarbonate', 'POLYESTER', 'POLYETHERIMIDE',
        'PE', 'polyisobutylene', 'Polyol', 'Polypropylene', 'POLYURETHANE', 'POLYVINYL ALCOHOL', 'POLYVINYL CHLORIDE',  'PTFE',
        'SILICONE', 'stryene']
        coswithref = [np.dot(ref_list[j], spectra_item_re) / (np.linalg.norm(ref_list[j]) * np.linalg.norm(spectra_item_re)) for j in range(len(ref_list))]
        match_result = pd.DataFrame((coswithref, name), index=['Cosine similarity', 'Compound name']).T 
        match_result_sorted = match_result.sort_values('Cosine similarity', ascending=False)
        #cos 순으로 정렬
        print(match_result_sorted)
        print(match_result_sorted.iat[0,1]) #cos 최댓값
        match_result_index = match_result_sorted.index.to_list()
        print(match_result_index)
        print(match_result_index[1])
        print(match_result_sorted.iat[1,0])
        print(type(match_result_sorted.iat[0,1][0]))

        self.detail_result_info.setRowCount(len(match_result_sorted))
                
        for j in range(len(match_result_sorted)):
            self.detail_result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(x_clicked)))
            self.detail_result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(y_clicked)))
            self.detail_result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(round(match_result_sorted.iat[j,0][0], 3))))
            self.detail_result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(match_result_sorted.iat[j,1])))

        self.figure_spectrum_detailed.clear()
        
        ax4 = self.figure_spectrum_detailed.subplots(6)
        [ax4[i].plot(spectra_item.columns.to_list(), spectra_item_re, label="Sample spectrum at specific point") for i in range(6)]
        [ax4[i+1].plot(spectra_item.columns.to_list(), ref_list[match_result_index[i]], label="{}".format(match_result_sorted.iat[i,1])) for i in range(5)]
        [ax4[i].xaxis.set_major_locator(MultipleLocator(500)) for i in range(6)]
        [ax4[i].xaxis.set_minor_locator(MultipleLocator(100)) for i in range(6)]
        [ax4[i].invert_xaxis() for i in range(6)]
        [ax4[i].legend(loc=1) for i in range(6)]
        #하나에 서브플롯 여러개. stack 형식
        [ax4[i+1].text(1400, 0.75, 'Cosine similarity: {}'.format(round(match_result_sorted.iat[i,0][0], 3))) for i in range(5)] #반올림 how?
        
        self.figure_spectrum_detailed.tight_layout()
        
        self.canvas_spectrum_detailed.draw()

    def show_annotation_corr(self, sel):
        lggMd.LogObj.info('Enter show_annotation_corr')
        x_hovered = np.round(sel.target[0], 2)
        y_hovered = np.round(sel.target[1], 2)
        print(x_hovered, y_hovered) 

        x_clicked = find_nearest(map_df['X'], x_hovered)
        x_clicked2 = find_second_near(map_df['X'], x_hovered)
        y_clicked = find_nearest(map_df['Y'], y_hovered) 
        y_clicked2 = find_second_near(map_df['Y'], y_hovered)
        print(x_clicked, y_clicked)
        print(x_clicked2, y_clicked2)
        sel.annotation.set_text('X = {}, Y = {}'.format(x_clicked, y_clicked))
        condition1 = (map_df['X'] == float(x_clicked)) & (map_df['Y'] == float(y_clicked))
        condition2 = (map_df['X'] == float(x_clicked)) & (map_df['Y'] == float(y_clicked2))
        condition3 = (map_df['X'] == float(x_clicked2)) & (map_df['Y'] == float(y_clicked))
        condition4 = (map_df['X'] == float(x_clicked2)) & (map_df['Y'] == float(y_clicked2))
        if map_df[condition1].iloc[:,2:].empty == False:
            spectra_item = map_df[condition1].iloc[:,2:]
        elif map_df[condition2].iloc[:,2:].empty == False:
            spectra_item = map_df[condition2].iloc[:,2:]
        elif map_df[condition3].iloc[:,2:].empty == False:
            spectra_item = map_df[condition3].iloc[:,2:]
        elif map_df[condition4].iloc[:,2:].empty == False:
            spectra_item = map_df[condition4].iloc[:,2:]
        else:
            spectra_item = map_df[0].iloc[:,2:]
        print(spectra_item) 
        print(spectra_item.index[0])
       
        self.figure_spectrum.clear()
        
        ax3 = self.figure_spectrum.subplots()
        ax3.plot(spectra_item.columns.to_list(), spectra_item.T.values.tolist(), label="Sample spectrum at specific point")
        ax3.plot(wn[0], refspec_new, label="Reference spectrum")
        ax3.invert_xaxis()
        ax3.legend(loc=1)
        ax3.xaxis.set_major_locator(MultipleLocator(500)) 
        ax3.xaxis.set_minor_locator(MultipleLocator(100))
        ax3.text(1490, 0.8, 'Correlation coefficient: {}'.format(corr[spectra_item.index[0]], 3))
        
        self.figure_spectrum.tight_layout()

        self.canvas_spectrum.draw() 

        ref_list = self.libraryconstruction()
        #불러온 ref list와 스펙트럼 계산하기

        spectra_item_re = spectra_item.values.flatten()
        print(ref_list[0])
        print(spectra_item.values.flatten())
        print(type(spectra_item.values.flatten()))
        name = ['Acrylic', 'Alkyd', 'Cellulose acetate trimellitate', 'Cellulose acetate', 'CSP_stryene acrylate_', 'epoxy resin ester', 
        'Ethylene acrylic acid', 'Ethylene ethyl acrylate copolymer', 'ethylene vinyl acetate copolymer', 'ethylene vinyl acetate polymer',
        'Ethylene Vinyl Acetate', 'ethylene_propylene', 'HDPE', 'LDPE', 'NYLON', 'PB', 'PE-co-methacrylic acid', 'Phenoxy resin',
        'PMMA', 'PET', 'PS', 'Polyacetal', 'Polyalkene', 'Polyamide', 'polybutylene terephthalate', 'Polycarbonate', 'POLYESTER', 'POLYETHERIMIDE',
        'PE', 'polyisobutylene', 'Polyol', 'Polypropylene', 'POLYURETHANE', 'POLYVINYL ALCOHOL', 'POLYVINYL CHLORIDE',  'PTFE',
        'SILICONE', 'stryene']
        corrwithref = [np.round(np.corrcoef(ref_list[j], spectra_item_re)[0, 1], 2) for j in range(len(ref_list))] 
        match_result = pd.DataFrame((corrwithref, name), index=['Correlation coefficient', 'Compound name']).T 
        match_result_sorted = match_result.sort_values('Correlation coefficient', ascending=False)
        #corr 순으로 정렬
        print(match_result_sorted)
        print(match_result_sorted.iat[0,1]) #cos 최댓값
        match_result_index = match_result_sorted.index.to_list()
        print(match_result_index)
        print(match_result_index[1])
        print(match_result_sorted.iat[1,0])
        print(type(match_result_sorted.iat[0,1]))

        self.detail_result_info.setRowCount(len(match_result_sorted))
                
        for j in range(len(match_result_sorted)):
            self.detail_result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(x_clicked)))
            self.detail_result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(y_clicked)))
            self.detail_result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(round(match_result_sorted.iat[j,0], 3))))
            self.detail_result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(match_result_sorted.iat[j,1])))

        self.figure_spectrum_detailed.clear()
        
        ax4 = self.figure_spectrum_detailed.subplots(6)
        [ax4[i].plot(spectra_item.columns.to_list(), spectra_item_re, label="Sample spectrum at specific point") for i in range(6)]
        [ax4[i+1].plot(spectra_item.columns.to_list(), ref_list[match_result_index[i]], label="{}".format(match_result_sorted.iat[i,1])) for i in range(5)]
        [ax4[i].xaxis.set_major_locator(MultipleLocator(500)) for i in range(6)]
        [ax4[i].xaxis.set_minor_locator(MultipleLocator(100)) for i in range(6)]
        [ax4[i].invert_xaxis() for i in range(6)]
        [ax4[i].legend(loc=1) for i in range(6)]
        #하나에 서브플롯 여러개. stack 형식
        [ax4[i+1].text(1400, 0.75, 'Correlation coefficient: {}'.format(round(match_result_sorted.iat[i,0], 3))) for i in range(5)] #반올림 how?
        
        self.figure_spectrum_detailed.tight_layout()
        
        self.canvas_spectrum_detailed.draw()         
    
    def tablecellclickedcos(self, row):
        lggMd.LogObj.info('Enter tablecellclickedcos')
        cellitem_x = self.result_info.item(row, 0).text()
        cellitem_y = self.result_info.item(row, 1).text()

        def find_second_near(array, value):
            array = np.asarray(array)
            L = list(np.abs(array - value))
            sorted_list = sorted(L)

            for i in range(len(sorted_list)):
                if sorted_list[i] != sorted_list[0]:
                    second_smallest = sorted_list[i] #loop 정지시키기
                    break

            min2 = L.index(second_smallest)

            return array[min2]
        
        cellitem_x_alter = find_second_near(map_df['X'], float(cellitem_x))
        cellitem_y_alter = find_second_near(map_df['Y'], float(cellitem_y))
        condition1 = (map_df['X'] == float(cellitem_x)) & (map_df['Y'] == float(cellitem_y))
        condition2 = (map_df['X'] == float(cellitem_x)) & (map_df['Y'] == float(cellitem_y_alter))
        condition3 = (map_df['X'] == float(cellitem_x_alter)) & (map_df['Y'] == float(cellitem_y))
        condition4 = (map_df['X'] == float(cellitem_x_alter)) & (map_df['Y'] == float(cellitem_y_alter))
        if map_df[condition1].iloc[:,2:].empty == False:
            spectra_item = map_df[condition1].iloc[:,2:]
        elif map_df[condition2].iloc[:,2:].empty == False:
            spectra_item = map_df[condition2].iloc[:,2:]
        elif map_df[condition3].iloc[:,2:].empty == False:
            spectra_item = map_df[condition3].iloc[:,2:]
        elif map_df[condition4].iloc[:,2:].empty == False:
            spectra_item = map_df[condition4].iloc[:,2:]
        print(spectra_item) 
        print(spectra_item.index[0])

        imgwithcellclicked=out_img.copy()

        x = XPoint[row]
        y = YPoint[row]
        r = Radius[row]

        cv2.drawMarker(imgwithcellclicked, (int(x), int(y)), color = 255, 
        markerType=cv2.MARKER_CROSS, markerSize=120, thickness=12)
        #annotation 붙이기

        self.figure_map.clear()
        ax2 = self.figure_map.subplots()

        im = ax2.imshow(imgwithcellclicked, extent=[np.min(XPos), np.max(XPos), np.min(YPos), np.max(YPos)])
        im.format_cursor_data = lambda e: ""
        self.figure_map.tight_layout(pad=0)

        self.canvas_map.draw()
        
        cursor = mplcursors.cursor(im, hover=False)
        cursor.connect('add', self.show_annotation_cos)
        

        self.figure_spectrum.clear()
        
        ax3 = self.figure_spectrum.subplots()
        ax3.plot(spectra_item.columns.to_list(), spectra_item.T.values.tolist(), label="Sample spectrum at specific point")
        ax3.plot(wn[0], refspec_new, label="Reference spectrum")
        ax3.invert_xaxis()
        ax3.legend(loc=1)
        ax3.xaxis.set_major_locator(MultipleLocator(500)) 
        ax3.xaxis.set_minor_locator(MultipleLocator(100))
        ax3.text(1490, 0.8, 'Cosine Similarity: {}'.format(cos[spectra_item.index[0]], 3))
        
        self.figure_spectrum.tight_layout()
        
        self.canvas_spectrum.draw()

        self.figure_spectrum_detailed.clear()
        
        ax4 = self.figure_spectrum_detailed.subplots(2)
        ax4[0].plot(spectra_item.columns.to_list(), spectra_item.T.values.tolist(), label="Sample spectrum at specific point")
        ax4[1].plot(spectra_item.columns.to_list(), refspec_new, label="Reference spectrum")
        ax4[0].invert_xaxis()
        ax4[1].invert_xaxis()
        ax4[0].legend()
        ax4[1].legend()
        #하나에 서브플롯 여러개. stack 형식
        #ax4[1].text(2000, 0.9, 'Cosine similarity: {}'.format(cos[0], 3))
        
        self.figure_spectrum_detailed.tight_layout()
        
        self.canvas_spectrum_detailed.draw()

        ref_list = self.libraryconstruction()
        #불러온 ref list와 스펙트럼 계산하기

        spectra_item_re = spectra_item.T.values.tolist()
        name = ['Acrylic', 'Alkyd', 'Cellulose acetate trimellitate', 'Cellulose acetate', 'CSP_stryene acrylate_', 'epoxy resin ester', 
        'Ethylene acrylic acid', 'Ethylene ethyl acrylate copolymer', 'ethylene vinyl acetate copolymer', 'ethylene vinyl acetate polymer',
        'Ethylene Vinyl Acetate', 'ethylene_propylene', 'HDPE', 'LDPE', 'NYLON', 'PB', 'PE-co-methacrylic acid', 'Phenoxy resin',
        'PMMA', 'PET', 'PS', 'Polyacetal', 'Polyalkene', 'Polyamide', 'polybutylene terephthalate', 'Polycarbonate', 'POLYESTER', 'POLYETHERIMIDE',
        'PE', 'polyisobutylene', 'Polyol', 'Polypropylene', 'POLYURETHANE', 'POLYVINYL ALCOHOL', 'POLYVINYL CHLORIDE',  'PTFE',
        'SILICONE', 'stryene']
        coswithref = [np.dot(ref_list[j], spectra_item_re) / (np.linalg.norm(ref_list[j]) * np.linalg.norm(spectra_item_re)) for j in range(len(ref_list))]
        match_result = pd.DataFrame((coswithref, name), index=['Cosine similarity', 'Compound name']).T 
        match_result_sorted = match_result.sort_values('Cosine similarity', ascending=False)
        #cos 순으로 정렬
        print(match_result_sorted)
        print(match_result_sorted.iat[0,1]) #cos 최댓값
        match_result_index = match_result_sorted.index.to_list()
        print(match_result_index)
        print(match_result_index[1])
        print(match_result_sorted.iat[1,0])
        print(type(match_result_sorted.iat[0,1][0]))

        self.detail_result_info.setRowCount(len(match_result_sorted))
                
        for j in range(len(match_result_sorted)):
            self.detail_result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(cellitem_x)))
            self.detail_result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(cellitem_y)))
            self.detail_result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(round(match_result_sorted.iat[j,0][0], 3))))
            self.detail_result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(match_result_sorted.iat[j,1])))

        self.figure_spectrum_detailed.clear()
        
        ax4 = self.figure_spectrum_detailed.subplots(6)
        [ax4[i].plot(spectra_item.columns.to_list(), spectra_item_re, label="Sample spectrum at specific point") for i in range(6)]
        [ax4[i+1].plot(spectra_item.columns.to_list(), ref_list[match_result_index[i]], label="{}".format(match_result_sorted.iat[i,1])) for i in range(5)]
        [ax4[i].xaxis.set_major_locator(MultipleLocator(500)) for i in range(6)]
        [ax4[i].xaxis.set_minor_locator(MultipleLocator(100)) for i in range(6)]
        [ax4[i].invert_xaxis() for i in range(6)]
        [ax4[i].legend(loc=1) for i in range(6)]
        #하나에 서브플롯 여러개. stack 형식
        [ax4[i+1].text(1400, 0.75, 'Cosine similarity: {}'.format(round(match_result_sorted.iat[i,0][0], 3))) for i in range(5)] #반올림 how?
        
        self.figure_spectrum_detailed.tight_layout()
        
        self.canvas_spectrum_detailed.draw()

    def tablecellclickedcorr(self, row):
        lggMd.LogObj.info('Enter tablecellclickedcorr')
        cellitem_x = self.result_info.item(row, 0).text()
        cellitem_y = self.result_info.item(row, 1).text()
        def find_second_near(array, value):
            array = np.asarray(array)
            L = list(np.abs(array - value))
            sorted_list = sorted(L)

            for i in range(len(sorted_list)):
                if sorted_list[i] != sorted_list[0]:
                    second_smallest = sorted_list[i] #loop 정지시키기
                    break

            min2 = L.index(second_smallest)

            return array[min2]
        
        cellitem_x_alter = find_second_near(map_df['X'], float(cellitem_x))
        cellitem_y_alter = find_second_near(map_df['Y'], float(cellitem_y))
        condition1 = (map_df['X'] == float(cellitem_x)) & (map_df['Y'] == float(cellitem_y))
        condition2 = (map_df['X'] == float(cellitem_x)) & (map_df['Y'] == float(cellitem_y_alter))
        condition3 = (map_df['X'] == float(cellitem_x_alter)) & (map_df['Y'] == float(cellitem_y))
        condition4 = (map_df['X'] == float(cellitem_x_alter)) & (map_df['Y'] == float(cellitem_y_alter))
        if map_df[condition1].iloc[:,2:].empty == False:
            spectra_item = map_df[condition1].iloc[:,2:]
        elif map_df[condition2].iloc[:,2:].empty == False:
            spectra_item = map_df[condition2].iloc[:,2:]
        elif map_df[condition3].iloc[:,2:].empty == False:
            spectra_item = map_df[condition3].iloc[:,2:]
        elif map_df[condition4].iloc[:,2:].empty == False:
            spectra_item = map_df[condition4].iloc[:,2:]
        print(spectra_item) 
        print(spectra_item.index[0])

        imgwithcellclicked=out_img.copy()

        x = XPoint[row]
        y = YPoint[row]
        r = Radius[row]

        cv2.drawMarker(imgwithcellclicked, (int(x), int(y)), color = 255, 
        markerType=cv2.MARKER_CROSS, markerSize=120, thickness=12)
        #annotation 붙이기

        self.figure_map.clear()
        ax2 = self.figure_map.subplots()

        im = ax2.imshow(imgwithcellclicked, extent=[np.min(XPos), np.max(XPos), np.min(YPos), np.max(YPos)])
        im.format_cursor_data = lambda e: ""
        self.figure_map.tight_layout(pad=0)

        self.canvas_map.draw() 
        cursor = mplcursors.cursor(im, hover=False)
        cursor.connect('add', self.show_annotation_corr)

        self.figure_spectrum.clear()
        
        ax3 = self.figure_spectrum.subplots()
        ax3.plot(spectra_item.columns.to_list(), spectra_item.T.values.tolist(), label="Sample spectrum at specific point")
        ax3.plot(wn[0], refspec_new, label="Reference spectrum")
        ax3.invert_xaxis()
        ax3.legend(loc=1)
        ax3.xaxis.set_major_locator(MultipleLocator(500)) 
        ax3.xaxis.set_minor_locator(MultipleLocator(100))
        ax3.text(1490, 0.8, 'Correlation coefficient: {}'.format(corr[spectra_item.index[0]], 3))
        
        self.figure_spectrum.tight_layout()
        
        self.canvas_spectrum.draw()

        self.figure_spectrum_detailed.clear()
        
        ax4 = self.figure_spectrum_detailed.subplots(2)
        ax4[0].plot(spectra_item.columns.to_list(), spectra_item.T.values.tolist(), label="Sample spectrum at specific point")
        ax4[1].plot(spectra_item.columns.to_list(), refspec_new, label="Reference spectrum")
        ax4[0].invert_xaxis()
        ax4[1].invert_xaxis()
        ax4[0].legend()
        ax4[1].legend()
        #하나에 서브플롯 여러개. stack 형식
        #ax4[1].text(2000, 0.9, 'Cosine similarity: {}'.format(cos[0], 3))
        
        self.figure_spectrum_detailed.tight_layout()
        
        self.canvas_spectrum_detailed.draw()

        ref_list = self.libraryconstruction()
        #불러온 ref list와 스펙트럼 계산하기

        spectra_item_re = spectra_item.values.flatten()
        name = ['Acrylic', 'Alkyd', 'Cellulose acetate trimellitate', 'Cellulose acetate', 'CSP_stryene acrylate_', 'epoxy resin ester', 
        'Ethylene acrylic acid', 'Ethylene ethyl acrylate copolymer', 'ethylene vinyl acetate copolymer', 'ethylene vinyl acetate polymer',
        'Ethylene Vinyl Acetate', 'ethylene_propylene', 'HDPE', 'LDPE', 'NYLON', 'PB', 'PE-co-methacrylic acid', 'Phenoxy resin',
        'PMMA', 'PET', 'PS', 'Polyacetal', 'Polyalkene', 'Polyamide', 'polybutylene terephthalate', 'Polycarbonate', 'POLYESTER', 'POLYETHERIMIDE',
        'PE', 'polyisobutylene', 'Polyol', 'Polypropylene', 'POLYURETHANE', 'POLYVINYL ALCOHOL', 'POLYVINYL CHLORIDE',  'PTFE',
        'SILICONE', 'stryene']
        corrwithref = [np.round(np.corrcoef(ref_list[j], spectra_item_re)[0, 1], 2) for j in range(len(ref_list))] 
        match_result = pd.DataFrame((corrwithref, name), index=['Correlation coefficient', 'Compound name']).T 
        match_result_sorted = match_result.sort_values('Correlation coefficient', ascending=False)
        print(match_result_sorted)
        print(match_result_sorted.iat[0,1]) 
        match_result_index = match_result_sorted.index.to_list()
        print(match_result_index)
        print(match_result_index[1])
        print(match_result_sorted.iat[1,0])
        print(type(match_result_sorted.iat[0,1]))

        self.detail_result_info.setRowCount(len(match_result_sorted))
                
        for j in range(len(match_result_sorted)):
            self.detail_result_info.setItem(j, 0, QtWidgets.QTableWidgetItem(str(cellitem_x)))
            self.detail_result_info.setItem(j, 1, QtWidgets.QTableWidgetItem(str(cellitem_y)))
            self.detail_result_info.setItem(j, 2, QtWidgets.QTableWidgetItem(str(round(match_result_sorted.iat[j,0], 3))))
            self.detail_result_info.setItem(j, 3, QtWidgets.QTableWidgetItem(str(match_result_sorted.iat[j,1])))

        self.figure_spectrum_detailed.clear()
        
        ax4 = self.figure_spectrum_detailed.subplots(6)
        [ax4[i].plot(spectra_item.columns.to_list(), spectra_item_re, label="Sample spectrum at specific point") for i in range(6)]
        [ax4[i+1].plot(spectra_item.columns.to_list(), ref_list[match_result_index[i]], label="{}".format(match_result_sorted.iat[i,1])) for i in range(5)]
        [ax4[i].xaxis.set_major_locator(MultipleLocator(500)) for i in range(6)]
        [ax4[i].xaxis.set_minor_locator(MultipleLocator(100)) for i in range(6)]
        [ax4[i].invert_xaxis() for i in range(6)]
        [ax4[i].legend(loc=1) for i in range(6)]
        #하나에 서브플롯 여러개. stack 형식
        [ax4[i+1].text(1400, 0.75, 'Correlation coefficient: {}'.format(round(match_result_sorted.iat[i,0], 3))) for i in range(5)] #반올림 how?
        
        self.figure_spectrum_detailed.tight_layout()
        
        self.canvas_spectrum_detailed.draw()

    def exportToExcel(self):
        lggMd.LogObj.info('Enter exportToExcel')
        columnHeaders = []

        # create column header list
        for j in range(self.result_info.columnCount()):
            columnHeaders.append(self.result_info.horizontalHeaderItem(j).text())

        df = pd.DataFrame(columns=columnHeaders)

        # create dataframe object recordset
        for row in range(self.result_info.rowCount()):
            for col in range(self.result_info.columnCount()):
                item = self.result_info.item(row, col)
                df.at[row, columnHeaders[col]] = item.text() if item is not None else ""
        print(df)

        Save, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Save file', './', 'csv(*.csv)')
        if Save:
            with open(Save, 'w', encoding='utf-8') as f:
                df.to_csv(Save)

        #df.to_csv('./information.csv', encoding='utf-8')
        #csv도 된다면 이전처럼 메시지상자 열고 제목 바꿔서 데이터 저장하게 하기
        print('file exported')

    def exportToExceldetail(self): # 두번째 탭의 정보 엑셀로 export
        lggMd.LogObj.info('Enter exportToExceldetail')
        columnHeaders = []

        # create column header list
        for j in range(self.detail_result_info.columnCount()):
            columnHeaders.append(self.detail_result_info.horizontalHeaderItem(j).text())

        df = pd.DataFrame(columns=columnHeaders)

        # create dataframe object recordset
        for row in range(self.detail_result_info.rowCount()):
            for col in range(self.detail_result_info.columnCount()):
                item = self.detail_result_info.item(row, col)
                df.at[row, columnHeaders[col]] = item.text() if item is not None else ""
        print(df)

        Save, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Save file', './', 'csv(*.csv)')
        if Save:
            with open(Save, 'w', encoding='utf-8') as f:
                df.to_csv(Save)

        #df.to_csv('./information.csv', encoding='utf-8')
        #csv도 된다면 이전처럼 메시지상자 열고 제목 바꿔서 데이터 저장하게 하기
        print('file exported')


    def retranslateUi(self, MainWindow):
        lggMd.LogObj.info('Enter retranslateUi')
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label_info.setText(_translate("MainWindow", "Result information"))
        self.label_spectrum.setText(_translate("MainWindow", "Spectrum"))
        self.label_image.setText(_translate("MainWindow", "Image"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Result), _translate("MainWindow", "Result"))
        
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.MLResult), _translate("MainWindow", "Result(ML)"))
        self.MLlabel_info.setText(_translate("MainWindow", "Result information"))
        self.MLlabel_image.setText(_translate("MainWindow", "Image"))
        self.MLlabel_spectrum.setText(_translate("MainWindow", "Spectrum"))

        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Detail_info), _translate("MainWindow", "Detail information"))
        self.menuSearch.setTitle(_translate("MainWindow", "Main"))
        self.menuCreate_map.setTitle(_translate("MainWindow", "Create map"))
        self.menuExport.setTitle(_translate("MainWindow", "Export"))
        self.actionShow_spectrum.setText(_translate("MainWindow", "Show spectrum"))
        self.actionCreate_cosine_map.setText(_translate("MainWindow", "Create Cosine map"))
        self.actionCreate_Correlation_map.setText(_translate("MainWindow", "Create Correlation map"))
        self.actionCreate_ML_map.setText(_translate("MainWindow", "Create ML map"))
        self.actionResult_information.setText(_translate("MainWindow", "Result information"))
        self.actionDetail_result_information.setText(_translate("MainWindow", "Detail result information"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
